<pre class='metadata'>
Title: Go language binding for Web IDL
Shortname: WebIDL-Go
Status: DREAM
Repository: jcbhmr/WebIDL-Go
URL: https://jcbhmr.me/WebIDL-Go/
Editor: Jacob Hummer, https://jcbhmr.me/
Abstract: Outline conventions & ideas for mapping Web IDL concepts & types into native Go patterns, conventions, and types.
Markup Shorthands: markdown yes
Boilerplate: omit conformance
!Participate: <a href="https://github.com/jcbhmr/WebIDL-Go">https://github.com/jcbhmr/WebIDL-Go</a>
</pre>

<div boilerplate="copyright">
Copyright ¬© Jacob Hummer. This work is licensed under a [Creative Commons Attribution 4.0 International License](https://github.com/jcbhmr/WebIDL-Go/blob/main/LICENSE). To the extent portions of it are incorporated into source code, such portions in the source code are licensed under the [BSD 3-Clause License](https://github.com/jcbhmr/WebIDL-Go/blob/main/LICENSE-CODE) instead.
</div>

<p style="margin-top: 2em; margin-bottom: -1em">
  <small>Not affiliated with Go, Google, W3C, or WHATWG.</small>
</p>

<div class=non-normative>
# Introduction # {#intro}
<i>This section is non-normative.</i>

üí° This document was inspired by [[WEBIDL-JAVA inline]] and [[WEBIDL inline]] JavaScript Bindings. This is just a rough collection of ideas on how to map types from [[WEBIDL inline]] to Go. It's like a miniature reference book. If you have a better way to do things, chances are you're right! [Open an Issue!](https://github.com/jcbhmr/WebIDL-Rust/issues/new) I'm always looking for more egonomic & better ways to translate Web IDL concepts to Go. ‚ù§Ô∏è

## Use case: Ergonomic Go ‚Üî Web API bindings ## {#use-case-1}

There currently is a lack of high-quality Go bindings to Web APIs for use when writing Go code that targets `GOOS=js` `GOARCH=wasm`.

<div class=example>

[dominikh/go-js-dom](https://github.com/dominikh/go-js-dom) provides a lot of bindings to access [[DOM inline]] APIs.
- It doesn't let you cast very easily. It's inconsistent with some types being `struct` and others being `interface`. The DX and ergonomics could be improved by using `interface` everywhere.
- It doesn't provide modern [[DOM]] features like {{ParentNode/append}}. It's a bit outdated. This could be improved with a Web IDL üëâ Go scaffolding generator and more formalized Go ‚Üî Web IDL rules.
- It doesn't handle optional primitives at all. {{nodeValue}} is a `DOMString?` in [[WEBIDL]] but is defined as `NodeValue() string` in go-js-dom. Using `nil`-able types would be more idiomatic Go.
- It doesn't work well with complex function signatures like {{EventTarget/addEventListener(type, callback, options)}} which has a callback interface and a union type. A standardized well-known way to idiomatically convert [[WEBIDL]] overloads, union types, and optional parameters to Go would be helpful.

</div>

<div class=example>

[realPy/hogosuru](https://github.com/realPy/hogosuru) is a Go web framework that offers some Web API bindings too.
- It doesn't embrace union types. {{EventTarget/addEventListener(type, callback, options)}} is represented only as `AddEventListener(string, func(Event))` with no options parameter. An ergonomic way to idiomatically represnt overloads and optional parameters in Go would be nice.
- Packages are fragmented. There are so many packages! One for each [[DOM]] definition is too many. A more cohesive API might group things based on which specification ([[DOM]], [[FETCH]], [[WEB-SHARE]], etc.) that they come from.
- Everything returns a `(T, error)`. This is just a gripe of how granular I think the error handling is.
- {{nodeValue}} is represented as `NodeValue() string` (with a bubbled error from `js.Value` `Get()`). The {{nodeValue}} of a node is actually `DOMString?` though. A standard way to represent nullable [[WEBIDL]] values in Go (particularily primitives) would help.

</div>

## Use case: Path to port Web APIs to Go ## {#use-case-2}

[[URLPATTERN inline]], [[DOM inline]], [[FETCH inline]], [[WEB-SHARE inline]], [[CLIPBOARD-APIS inline]], and more are all cool Web APIs that could be ported to Go. Not because being Web IDL-based is better than a custom API, but because it gives developers a very concrete API surface to cover. And as a side effect it makes it very easy to bind to the existing JavaScript bindings of the same Web API.

üåé JavaScript APIs are also very familiar to most web developers and it's very cool üòé when you can use the same concepts and libraries uniformly across domains and languages. It's just cool.

</div><!-- /intro -->

# Go binding # {#go-binding}

1. You should use Go 1.11 modules when developing Go Web IDL bindings. That means `go mod init` and not `GOPATH`.
2. Try to group things based on which specification they are a part of. This helps segement the vast collection of browser APIs into develop-able chunks.
3. Put everything on one level. Don't nest things in sub-packages; put it all on the root. Some developers will want to `import . "github.com/octocat/go-fetch"` to make `Fetch()` and all associated things top-level.
4. The {{Window}}, {{WorkerGlobalScope}}, etc. interfaces are all ‚ú®special since they are global interfaces. Anything that would be defined as a method on {{Window}} or other global scope interface should be defined **directly at the top level of the Go package** instead of as methods on a `Window` `struct`/`interface`. You should also **omit** the {{Window}} and other global interfaces from the types that you define. Think of {{Window}} as an invisible package-level interface instead of a concrete type.
6. Many Web IDL definitions (particularily in [[HTML inline]]) will make reference to "the global document" or "the current window". There is no "current window" in a typical Go program. You should try to follow the spirit if not the letter of these definitions.

<div class=example>
```webidl
partial interface Window {
  undefined alert(DOMString message);
};
```
```go
func Alert(message string) {
  // ...
}
```
</div>

## Names ## {#go-names}

<p class=note>
[Remember: to be exported from a package a Go name must start with an uppercase letter.](https://go.dev/tour/basics/3)
</p>

Use your own best judgement to split the words and PascalCase-ify them to make them conform to the Go convention. Note that initialisms should be all-caps.

For const & static members of interfaces, use the interface name followed by the member name.

For Web IDL constructors use `New` followed by the interface name.

<div class=example>
<pre class=simpledef>
{{Element/innerHTML}}: e.InnerHTML()
{{getElementById}}: document.GetElementByID()
{{HTMLLabelElement/htmlFor}}: e.HTMLFor()
{{Response/url}}: r.URL()
{{XMLHttpRequest}}: XMLHTTPRequest
{{HTMLHtmlElement}}: HTMLHTMLElement
{{HTMLPreElement}}: HTMLPreElement
{{Node}}.{{TEXT_NODE}}: NodeTextNode
{{Document/doctype}}: document.Doctype()
{{Element/id}}: e.ID()
new {{Document}}: NewDocument
</pre>
</div>

If you spot these letters in a Web IDL API name you should treat them as a single word: XML, HTTP, URL, ID, HTML, RTC, IDB.

## Go type mapping ## {#go-type-mapping}

<p class=issue>
Looking for a Go Web IDL helper library to recommend here. üëÄ
</p>

<p class=note>
Can't find a Web IDL type defined in this section? [Add it yourself](https://github.com/jcbhmr/WebIDL-Go) or [open an issue](https://github.com/jcbhmr/WebIDL-Go/issues/new). ‚ù§Ô∏è
</p>

The following list of types doesn't require much explaining.

<pre class=simpledef>
any: any
boolean: bool
byte: int8
octet: byte
short: int16
unsigned short: uint16
long: int32
unsigned long: uint32
long long: int64
unsigned long long: uint64
unrestricted float: float32
unrestricted double: float64
bigint: [math/big.Int](https://pkg.go.dev/math/big#Int)
DOMString: string
ByteString: string
</pre>

### Restricted float and double ### {#go-float-double}

<p class=note>
Reminder: the `unrestricted double` type means that the value *can* be `NaN`, `+Infinity`, or `-Infinity`. The counterpart is the plain old `double` type which *cannot* be `NaN`, `+Infinity`, or `-Infinity`.
</p>

Web IDL `float` values in Go are represented as Go `float32` values. Web IDL `double` values in Go are represented as Go `float64` values.

Implementers should `panic()` if their input Go `float32` or `float64` value is `NaN`, `+Infinity`, or `-Infinity` when the Web IDL signature uses a restricted `float` or `double` type.

<div class=example>
```webidl
partial interface Window {
  double add(double a, double b);
  unrestricted double addUnrestricted(unrestricted double a, unrestricted double b);
};
```
```go
func Add(a, b float64) float64 {
  if math.IsNaN(a) || math.IsInf(a, 0) { panic("a is not a double") }
  if math.IsNaN(b) || math.IsInf(b, 0) { panic("b is not a double") }
  return a + b
}
func AddUnrestricted(a, b float64) float64 {
  return a + b
}
```
</div>

### `undefined` ### {#go-undefined}

**In function return position** `undefined` should be omitted from the Go function signature.

<div class=example>
```webidl
interface Storage {
  setter undefined setItem(DOMString name, DOMString value);
  // ...
};
```
```go
type Storage interface {
  SetItem(name string, value string)
}
```
</div>

**When used in `sequence<undefined>`** or other places where a type is required use `struct{}`.

<div class=example>
```webidl
interface A {
  sequence<undefined> doThing();
};
```
```go
type A interface {
  DoThing() []struct{}
}
```
</div>

**When part of a type union** treat it like a nullable `?` type.

<div class=example>
```webidl
interface CustomElementRegistry {
  (CustomElementConstructor or undefined) get(DOMString name);
  // ...
};
callback CustomElementConstructor = HTMLElement ();
```
```go
type CustomElementRegistry interface {
  // CustomElementConstructor is a nil-able type.
  Get(name string) CustomElementConstructor
}
type CustomElementConstructor = func() HTMLElement
```
</div>

### `USVString` ### {#go-usvstring}

> The USVString type corresponds to scalar value strings. Depending on the context, these can be treated as sequences of either 16-bit unsigned integer code units or scalar values.

<div class=issue>

Honestly I'm not entirely sure how to represent `USVString` in Go.

If you have a better explaination or some other insight into what `DOMString` vs `USVString` means in the context of a Go string I'm all ears. üòä

</div>

```go
func DoThing(v string) {
  if !utf8.Valid(v) { panic("v is not a well-formed UTF-8 string") }
}
```

### `object` ### {#go-object}

`object` is similar to `any` but it **cannot be `null` or a primitive**. In Go-land that means it's like `any` just with a `panic()` check to make sure it's not `nil` or a `string|int|bool|etc...` type.

<div class=example>
```go
func DoThing(v any) {
  if v == nil || reflect.ValueOf(v).Kind() < reflect.Array {
    panic("v is not object type")
  }
}
```
</div>

### `symbol` ### {#go-symbol}

Not yet defined.

### Interface types ### {#go-interface}

To support downcasting ({{Node}} üëâ {{HTMLAnchorElement}}) easily Web IDL types are represented as Go `interface` instead of `struct`. Each Web IDL `interface` type should have a corresponding Go `interface` type. Unless it's {{Window}} or another global interface, in which case it should be omitted and all its members should go in the package scope.

<div class=example>
```webidl
interface Node : EventTarget {
  readonly attribute DOMString nodeName;
};
interface Window {
  undefined alert(DOMString message);
};
```
```go
type Node interface {
  EventTarget
  NodeName() string
}
func Alert(message string) {}
```
</div>

<div class=note>

You can't downcast a `struct` `*Node` into a `struct` `*HTMLAudioElement` in Go. You can only cast with `interface`-es. This means that if `.QuerySelector()` returns a `*Element` then there's no way to try to `instanceof HTMLAnchorElement` or `instanceof HTMLVideoElement` and then cast it to those types to use `.Click()` or `.Play()`.

```go
element, err := document.QuerySelector("audio")
// This won't work
audio := element.(*HTMLAudioElement)
// So how do you convert element (which is *Element) into an *HTMLAudioElement?
```

```go
element, err := document.QuerySelector("audio")
// This is how you do it
audio := element.(HTMLAudioElement)
```
</div>

**Interface constructors** are pulled out into a `New___()` function where you fill in the blank with the interface name. For example the `Request` interface has a constructor `NewRequest()`. For interfaces without a constructor you should omit this `New___()` function. Treat interface constructors as though they were their own {{Window}} function and apply all the same union, overload, and optional rules.

<div class=example>
```webidl
[Exposed=(Window,Worker)]
interface Headers {
  constructor(optional HeadersInit init);
  // ...
};
```

```go
func NewHeaders() Headers {}
func NewHeadersInit(init any) Headers {}
```
</div>

#### `interface mixin` #### {#go-interface-mixin}

Mixins are used by Web IDL to define a set of functions implemented by multiple interfaces. The best example of this is the {{Body}} mixin which defines {{Body/arrayBuffer}}, {{Body/text}}, and {{Body/json}} on {{Request}} and {{Response}} objects.

In Go, that just corrolates to an embedded interface!

<div class=example>
```webidl
interface mixin Body {
  readonly attribute boolean bodyUsed;
  [NewObject] Promise<ArrayBuffer> arrayBuffer();
  // ...
};
Request includes Body;
Response includes Body;
```
```go
type Body interface {
  BodyUsed() bool
  ArrayBuffer() func() ([]byte, error)
  // ...
}
type Request interface {
  Body
}
type Response interface {
  Body
}
```
</div>

### Callback interface types ### {#go-callback-interface}

<div class=note>

Callback interfaces are a way to codify the below into Web IDL:

```js
// Both of these work!
globalThis.addEventListener("load", { handleEvent: () => console.log("handleEvent") })
globalThis.addEventListener("load", () => console.log("function"))
```

It's rarely used.

</div>

Treat callback interfaces as though they were just a union type of the function signature and an unnamed interface with that single method defined. Practically, this means that callback interfaces are represented as `any`.

You should provide a same-name `type TheCallbackInterface = func(...)...` type as well as an `interface` type with the suffix `Object` like `type TheCallbackInterfaceObject interface {...}`.

<div class=example>
```webidl
interface Thing {
  undefined addEventListener(listener EventListener);
};
callback interface EventListener {
  undefined handleEvent(Event event);
};
```
```go
type EventListener func(event Event)
type EventListenerObject interface {
  HandleEvent(event Event)
}

func (e *thingImpl) AddEventListener(listener any) {
  if b, ok := a.(EventListenerObject); ok {
    // Can use like this:
    b.HandleEvent(event)
  } else if b, ok := a.(EventListener); ok {
    // Can use like this:
    b(event)
  } else {
    panic("listener is not an EventListener or EventListenerObject")
  }
}
```
</div>

### Dictionary types ### {#go-dictionary}

Web IDL interfaces map quite well to Go `struct`. The biggest obstacle here is optional `struct` fields. Since Go doesn't have a Rust `Option<T>` or a Java `null`-able primitive (`Integer`, `Double`, `String`) objects it means we need to use something else. The most Go-like way of doing things is with `nil`-able types. For interfaces this is no sweat: interfaces are always `nil`-able. For primitives it means passing by `*string` instead of `string`.

<div class=note>

Go doesn't let you to take the `&` address of literal values. You can use a helper function like this for that:

```go
func ptr[T any](v T) *T {
  return &v
}

func DoThing(v *string) {}

func main() {
  // Doesn't work üò¢
  // DoThing(&"hello ptr magic!")

  // Works! üòÑ
  DoThing(ptr("hello ptr magic!"))
}
```
</div>

<div class=example>
```webidl
dictionary ResponseInit {
  unsigned short status = 200;
  ByteString statusText = "";
  HeadersInit headers;
};
```
```go
type ResponseInit struct {
  Status *uint16
  StatusText *string
  Headers any
}
```
</div>

Dictionaries that extend other dictionaries should be **completely flattened** into a single `struct`. This is more ergonomic from a consumer's perspective since all the fields are flattened one level deep instead of being nested.

<div class=example>

```webidl
dictionary AddEventListenerOptions : EventListenerOptions {
  boolean passive = false;
  boolean once = false;
};
dictionary EventListenerOptions {
  boolean capture = false;
};
```

Here's an example of what this "flattening" aims to **avoid**. **üõë This is the *incorrect* way to represent this Web IDL dictionary.**

```go
type AddEventListenerOptions struct {
  EventListenerOptions // üëà Embedded struct!
  Passive *bool
  Once *bool
}
type EventListenerOptions struct {
  Capture *bool
}
```

```go
// ü§∑‚Äç‚ôÄÔ∏è Not ideal.
AddEventListener("click", listener, AddEventListenerOptions{
  EventListenerOptions: EventListenerOptions{
    Capture: ptr(true),
  },
  Passive: ptr(true),
  Once: ptr(true),
})
```

Why is this bad? Because it introduces an unnecessary level of nesting when constructing a dictionary which has an inheritance chain like {{AddEventListenerOptions}}. Since most of the use of these dictionaries will be in constructing them, not reading from them (reading admittedly is very ergonomic with Go struct embedding) it's better to flatten them for the benefit of the user.

```go
// üëç Better.
AddEventListener("click", listener, AddEventListenerOptions{
  Capture: ptr(true),
  Passive: ptr(true),
  Once: ptr(true),
})
```

</div>

I'm open to being wrong about nested structs being bad. Give me your experience! Maybe embedded structs are better.

### Enumeration types ### {#go-enumeration}

Todo

### Callback function types ### {#go-callback-function}

Use a `type TheType func(...)...` newtype.

<div class=example>
```webidl
callback TheCallback = long (long a, long b);
```
```go
type TheCallback func(a int32, b int32) int32

func useTheCallback(cb TheCallback) {
  fmt.Printf("Result: %d", cb(1, 2))
}

func main() {
  useTheCallback(func(a int32, b int32) int32 {
    return a + b
  })
}
```
</div>

### Promise types ### {#go-promise}

Promises are a bit tricky in Go. Unlike `<-chan T`, a `Promise<T>` can be `await`-ed multiple times and will always spit out the same cached value. Similar to a `sync.OnceValue()` function. What this means is that just `<-chan T` isn't enough to represent a `Promise<T>` in Go. It falls apart specifically when you have a static `Promise<T>` that you want to `await` multiple times like {{ServiceWorkerContainer/ready}}.

Instead, the solution is to use a getter function. The current idiom that seems favored by Go is to *return a closure* that you can call multiple times and will await/return the same value each time. Basically just return a `sync.OnceFunc()`, `sync.OnceValue()`, or `sync.OnceValues()`.

Here's how you can represent `Promise<T>` in Go. The `func() (T, error)` signature **is what you return from the method**, not the signature of the method itself that returns the `Promise<T>`. The closure *is* the promise which can be called (awaited) at a later time or immediately any number of times.

<pre class=simpledef>
Promise&lt;T>: func() (T, error)
Promise&lt;undefined>: func() error
Infalliable Promise&lt;T>: func() T
Infalliable Promise&lt;undefined>: func()
</pre>

An <dfn export>infalliable promise</dfn> is a promise that never errors. These are **extremely rare** in Web APIs since most things that are async call system-level operations that can often fail for arbitrary reasons. If you see a `Promise<T>` in Web IDL it's almost always a `Promise<T>` and not an infalliable promise.

<p class=note>
{{ServiceWorkerContainer/ready}} is an example of the rare case where a `Promise<T>` will never reject.
</p>

<div class=example>
```webidl
partial interface ServiceWorkerContainer {
  readonly attribute Promise<ServiceWorkerRegistration> ready;
};
```
```go
type ServiceWorkerContainer interface {
  Ready() func() ServiceWorkerRegistration
}
```
</div>

The returned closure should support being called concurrently. This means that the closure should be safe to call from multiple goroutines at the same time. `sync.OnceFunc()` and friends handle this for you.
