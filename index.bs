<pre class='metadata'>
Title: Go language binding for Web IDL
Shortname: WebIDL-Go
Status: DREAM
Repository: jcbhmr/WebIDL-Go
URL: https://jcbhmr.me/WebIDL-Go/
Editor: Jacob Hummer, https://jcbhmr.me/
Abstract: Outline conventions & ideas for mapping Web IDL concepts & types into native Go patterns, conventions, and types.
Markup Shorthands: markdown yes
Boilerplate: omit conformance
!Participate: <a href="https://github.com/jcbhmr/WebIDL-Go">https://github.com/jcbhmr/WebIDL-Go</a>
</pre>

<div boilerplate="copyright">
Copyright ¬© Jacob Hummer. This work is licensed under a [Creative Commons Attribution 4.0 International License](https://github.com/jcbhmr/WebIDL-Go/blob/main/LICENSE). To the extent portions of it are incorporated into source code, such portions in the source code are licensed under the [BSD 3-Clause License](https://github.com/jcbhmr/WebIDL-Go/blob/main/LICENSE-CODE) instead.
</div>

<p style="margin-top: 2em; margin-bottom: -1em">
  <small>Not affiliated with Go, Google, W3C, or WHATWG.</small>
</p>

<div class=non-normative>
# Introduction # {#intro}
<i>This section is non-normative.</i>

üí° This document was inspired by [[WEBIDL-JAVA inline]] from 2013. This is just a rough collection of ideas on how to map types from [[WEBIDL inline]] to Go. It's like a miniature reference book. If you have a better way to do things, chances are you're right! [Open an Issue!](https://github.com/jcbhmr/WebIDL-Rust/issues/new) I'm always looking for more egonomic & better ways to translate Web IDL concepts to Go. ‚ù§Ô∏è

## Use case 1: Ergonomic Go ‚Üî Web API bindings ## {#use-case-1}

There currently is a lack of high-quality Go bindings to Web APIs for use when writing Go code that targets `GOOS=js` `GOARCH=wasm`.

<div class=example>

[dominikh/go-js-dom](https://github.com/dominikh/go-js-dom) provides a lot of bindings to access [[DOM inline]] APIs.
- It doesn't let you cast very easily. It's inconsistent with some types being `struct` and others being `interface`. The DX and ergonomics could be improved by using `interface` everywhere.
- It doesn't provide modern [[DOM]] features like {{ParentNode/append}}. It's a bit outdated. This could be improved with a Web IDL üëâ Go scaffolding generator and more formalized Go ‚Üî Web IDL rules.
- It doesn't handle optional primitives at all. {{nodeValue}} is a `DOMString?` in [[WEBIDL]] but is defined as `NodeValue() string` in go-js-dom. Using `nil`-able types would be more idiomatic Go.
- It doesn't work well with complex function signatures like {{EventTarget/addEventListener(type, callback, options)}} which has a callback interface and a union type. A standardized well-known way to idiomatically convert [[WEBIDL]] overloads, union types, and optional parameters to Go would be helpful.

</div>

<div class=example>

[realPy/hogosuru](https://github.com/realPy/hogosuru) is a Go web framework that offers some Web API bindings too.
- It doesn't embrace union types. {{EventTarget/addEventListener(type, callback, options)}} is represented only as `AddEventListener(string, func(Event))` with no options parameter. An ergonomic way to idiomatically represnt overloads and optional parameters in Go would be nice.
- Packages are fragmented. There are so many packages! One for each [[DOM]] definition is too many. A more cohesive API might group things based on which specification ([[DOM]], [[FETCH]], [[WEB-SHARE]], etc.) that they come from.
- Everything returns a `(T, error)`. This is just a gripe of how granular I think the error handling is.
- {{nodeValue}} is represented as `NodeValue() string` (with a bubbled error from `js.Value` `Get()`). The {{nodeValue}} of a node is actually `DOMString?` though. A standard way to represent nullable [[WEBIDL]] values in Go (particularily primitives) would help.

</div>

## Use case 2: Path to port Web APIs to Go ## {#use-case-2}

[[URLPATTERN inline]], [[DOM inline]], [[FETCH inline]], [[WEB-SHARE inline]], [[CLIPBOARD-APIS inline]], and more are all cool Web APIs that could be ported to Go. Not because being Web IDL-based is better than a custom API, but because it gives developers a very concrete API surface to cover. And as a side effect it makes it very easy to bind to the existing JavaScript bindings of the same Web API.

üåé JavaScript APIs are also very familiar to most web developers and it's very cool üòé when you can use the same concepts and libraries uniformly across domains and languages. It's just cool.

> The original use case for this was to play around and implement the JavaScript `fetch()` function in Go. Problems arose when there were diverging ways to implement `Promise<Response>`. Should it be a `Promise[T]`? A channel? How would it integrate with other concurrency stuff? What if this theoretical `github.com/octocat/fetch` package could use the browser's native `fetch()` API if it were running in `GOOS=js`? Then it spiraled from there into questions like "well how do you represent DOM node inheritance?" and "what if I want to downcast a `Node` from `QuerySelector()` into an `HTMLAnchorElement`?". All of that meant I had to think and pick an arbitrary way to represent Web IDL types in Go-land.

&mdash; [@jcbhmr](https://jcbhmr.me/)

</div><!-- /intro -->
# Go binding # {#go-binding}

1. You should use Go 1.11 modules when developing Go Web IDL bindings. That means `go mod init` and not `GOPATH`.
2. Try to group things based on which specification they are a part of. This helps segement the vast collection of browser APIs into develop-able chunks.
3. Put everything on one level. Don't nest things in sub-packages; put it all on the root. Some developers will want to `import . "github.com/octocat/go-fetch"` to make `Fetch()` and all associated things top-level.
4. Favor developer ergonomics over precise compliance with this document & [[WEBIDL]]. If making a function argument type just a little bit more specific than `any` (like `map[string]map[string]any`) makes things better then do that.
5. The {{Window}}, {{WorkerGlobalScope}}, etc. interfaces are all ‚ú®special since they are global interfaces. Anything that would be defined as a method on {{Window}} or other global scope interface should be defined **directly at the top level of the Go package** instead of as methods on a `Window` `struct`/`interface`. You should also **omit** the {{Window}} and other global interfaces from the types that you define. Think of {{Window}} as an invisible package-level interface instead of a concrete type.
6. Many Web IDL definitions (particularily in [[HTML inline]]) will make reference to "the global document" or "the current window". There is no "current window" in a typical Go program. You should try to follow the spirit if not the letter of these definitions.

<div class=example>
```webidl
partial interface Window {
  undefined alert(DOMString message);
};
```
```go
func Alert(message string) {
  // ...
}
```
</div>

## Names ## {#go-names}

<p class=note>
[Remember: to be exported from a package a Go name must start with an uppercase letter.](https://go.dev/tour/basics/3)
</p>

Use your own best judgement to split the words and PascalCase-ify them to make them conform to the Go convention. Note that initialisms should be all-caps.

For const & static members of interfaces, use the interface name followed by the member name.

For Web IDL constructors use `New` followed by the interface name.

<div class=example>
<pre class=simpledef>
{{Element/innerHTML}}: InnerHTML
{{getElementById}}: GetElementByID
{{HTMLLabelElement/htmlFor}}: HTMLFor
{{Response/url}}: URL
{{XMLHttpRequest}}: XMLHTTPRequest
{{HTMLHtmlElement}}: HTMLHTMLElement
{{HTMLPreElement}}: HTMLPreElement
{{Node}}.{{TEXT_NODE}}: NodeTextNode
{{Document/doctype}}: Doctype
{{Element/id}}: ID
new {{Document}}: NewDocument
</pre>
</div>

If you spot these letters in a Web IDL API name you should treat them as a single word: XML, HTTP, URL, ID, HTML, RTC, IDB.

## Go type mapping ## {#go-type-mapping}

<p class=issue>
Looking for a Go Web IDL helper library to recommend here. üëÄ
</p>

<p class=note>
Can't find a Web IDL type defined in this section? [Add it yourself](https://github.com/jcbhmr/WebIDL-Go) or [open an issue](https://github.com/jcbhmr/WebIDL-Go/issues/new). ‚ù§Ô∏è
</p>

The following list of types doesn't require much explaining.

<pre class=simpledef>
any: any
boolean: bool
byte: int8
octet: byte
short: int16
unsigned short: uint16
long: int32
unsigned long: uint32
long long: int64
unsigned long long: uint64
unrestricted float: float32
unrestricted double: float64
bigint: [math/big.Int](https://pkg.go.dev/math/big#Int)
DOMString: string
ByteString: string
</pre>

### Restricted float and double ### {#go-float-double}

<p class=note>
Reminder: the `unrestricted double` type means that the value *can* be `NaN`, `+Infinity`, or `-Infinity`. The counterpart is the plain old `double` type which *cannot* be `NaN`, `+Infinity`, or `-Infinity`.
</p>

Web IDL `float` values in Go are represented as Go `float32` values. Web IDL `double` values in Go are represented as Go `float64` values.

Implementers should `panic()` if their input Go `float32` or `float64` value is `NaN`, `+Infinity`, or `-Infinity` when the Web IDL signature uses a restricted `float` or `double` type.

<div class=example>
```webidl
partial interface Window {
  double add(double a, double b);
  unrestricted double addUnrestricted(unrestricted double a, unrestricted double b);
};
```
```go
func Add(a, b float64) float64 {
  if math.IsNaN(a) || math.IsInf(a, 0) { panic("a is not a double") }
  if math.IsNaN(b) || math.IsInf(b, 0) { panic("b is not a double") }
  return a + b
}
func AddUnrestricted(a, b float64) float64 {
  return a + b
}
```
</div>

### `USVString` ### {#go-usvstring}

> The USVString type corresponds to scalar value strings. Depending on the context, these can be treated as sequences of either 16-bit unsigned integer code units or scalar values.

<div class=issue>

Honestly I'm not entirely sure how to represent `USVString` in Go.

If you have a better explaination or some other insight into what `DOMString` vs `USVString` means in the context of a Go string I'm all ears. üòä

</div>

```go
func DoThing(v string) {
  if !utf8.Valid(v) { panic("v is not a well-formed UTF-8 string") }
}
```

### `undefined` ### {#go-undefined}

**In function return position** `undefined` should be omitted from the Go function signature.

<div class=example>
```webidl
interface Storage {
  setter undefined setItem(DOMString name, DOMString value);
  // ...
};
```
```go
type Storage interface {
  SetItem(name string, value string)
}
```
</div>

**When used in `sequence<undefined>`** or other places where a type is required use `struct{}`.

<div class=example>
```webidl
interface A {
  sequence<undefined> doThing();
};
```
```go
type A interface {
  DoThing() []struct{}
}
```
</div>

**When part of a type union** treat it like a nullable `?` type.

<div class=example>
```webidl
interface CustomElementRegistry {
  (CustomElementConstructor or undefined) get(DOMString name);
  // ...
};
callback CustomElementConstructor = HTMLElement ();
```
```go
type CustomElementRegistry interface {
  // CustomElementConstructor is a nil-able type.
  Get(name string) CustomElementConstructor
}
type CustomElementConstructor = func() HTMLElement
```
</div>

### `object` type ### {#go-object}

`object` is similar to `any` but it **cannot be `null` or a primitive**. In Go-land that means it's like `any` just with a `panic()` check to make sure it's not `nil` or a `string|int|bool|etc...` type.

<div class=example>
```go
func DoThing(v any) {
  if v == nil || reflect.ValueOf(v).Kind() < reflect.Array {
    panic("v is not object type")
  }
}
```
</div>

### Interface types ### {#go-interface}

To support downcasting ({{Node}} üëâ {{HTMLAnchorElement}}) easily Web IDL types are represented as Go `interface` instead of `struct`. Each Web IDL `interface` type should have a corresponding Go `interface` type. Unless it's {{Window}} or another global interface, in which case it should be omitted and all its members should go in the package scope.

<div class=example>
```webidl
interface Node {
  readonly attribute DOMString nodeName;
};
interface Window {
  undefined alert(DOMString message);
}l
```
```go
type Node interface {
  NodeName() string
}
func Alert(message string) {}
```
</div>

<div class=note>

You can't downcast a `struct` `*Node` into a `struct` `*HTMLAudioElement` in Go. You can only cast with `interface`-es. This means that if `.QuerySelector()` returns a `*Element` then there's no way to try to `instanceof HTMLAnchorElement` or `instanceof HTMLVideoElement` and then cast it to those types to use `.Click()` or `.Play()`.

```go
element, err := document.QuerySelector("audio")
// This won't work
audio := element.(*HTMLAudioElement)
// So how do you convert element (which is *Element) into an *HTMLAudioElement?
```

```go
element, err := document.QuerySelector("audio")
// This is how you do it
audio := element.(HTMLAudioElement)
```
</div>

**Interface constructors** are pulled out into a `New___()` function where you fill in the blank with the interface name. For example the `Request` interface has a constructor `NewRequest()`. For interfaces without a constructor you should omit this `New___()` function. Treat interface constructors as though they were their own {{Window}} function and apply all the same union, overload, and optional rules.

<div class=example>
```webidl
[Exposed=(Window,Worker)]
interface Headers {
  constructor(optional HeadersInit init);
  // ...
};
```

```go
func NewHeaders() Headers {}
func NewHeadersInit(init any) Headers {}
```
</div>

#### `interface mixin` #### {#go-interface-mixin}

Mixins are used by Web IDL to define a set of functions implemented by multiple interfaces. The best example of this is the {{Body}} mixin which defines {{Body/arrayBuffer}}, {{Body/text}}, and {{Body/json}} on {{Request}} and {{Response}} objects.

In Go, that just corrolates to an embedded interface!

<div class=example>
```webidl
interface mixin Body {
  readonly attribute boolean bodyUsed;
  [NewObject] Promise<ArrayBuffer> arrayBuffer();
  // ...
};
Request includes Body;
Response includes Body;
```
```go
type Body interface {
  BodyUsed() bool
  ArrayBuffer() func() ([]byte, error)
	// ...
}
type Request interface {
  Body
}
type Response interface {
  Body
}
```
</div>

### Callback interface types ### {#go-callback-interface}

<div class=note>

Callback interfaces are a way to codify the below into Web IDL:

```js
// Both of these work!
globalThis.addEventListener("load", { handleEvent: () => console.log("handleEvent") })
globalThis.addEventListener("load", () => console.log("function"))
```

It's rarely used.

</div>

Treat callback interfaces as though they were just a union type of the function signature and an unnamed interface with that single method defined. Practically, this means that callback interfaces are represented as `any`.

<div class=example>
```go
// You can edit this code!
// Click here and start typing.
package main

import "fmt"

func DoThing(a any) {
	if b, ok := a.(interface{ Ok() }); ok {
		b.Ok()
	} else {
		fmt.Println("not ok")
	}
}

type C struct{}

func (C) Ok() {
	fmt.Println("ok")
}

func main() {
	x := &C{}
	DoThing(x)
	// Output: ok
}
```
</div>